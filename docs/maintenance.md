---
title: Apache Mesos - Performing Maintenance
layout: documentation
---

# Mesosクラスタでのノードメンテナンス
オペレーターは、Mesosクラスタを構成するマシンのメンテナンスタスクを定期的に実行する必要があります。ほとんどのMesosのアップグレードは、実行中のタスクに影響を与えることなく行うことができますが、メンテナンスが実行中のタスクに影響を与える状況もあります。例えば、以下のようなものです。

* ハードウェアの修理
* カーネルのアップグレード
* エージェントのアップグレード（例：エージェントの属性やリソースの調整）

Mesosクラスタ内のエージェントノードのメンテナンスを行う前に、一般的には、マシンが停止したときのサービスの中断を最小限に抑えるために、事前にノードからタスクをグレースマイグレーションすることが望ましいです。Mesosには、この移行を行うためのいくつかの方法があります。

* `Automatic agent draining`: スケジューラの協力を明示的に必要としません。
* `Manual node draining`: オペレータがタスクドレインプロセスを正確に制御することができます。
* `Maintenance primitives`: 複雑な調整を可能にするが、スケジューラが受け取ったメンテナンス関連のメッセージに対応する必要がある。

# `Automatic Node Draining`
ノード・ドレインは、オペレータがメンテナンスを行う予定のノードからタスクをドレインするための簡単な方法を提供するために追加されました。この方法では、スケジューラがメンテナンス固有のメッセージのサポートを実装する必要はありません。

ドレインを開始すると、対象となるエージェント・ノード上のすべてのタスクは、エージェントが現在到達可能であることを前提に、直ちにキル・イベントを受け取ります。エージェントが到達できない場合は、エージェントがマスターから再び到達できるようになるまで、キルイベントの開始が遅れます。タスクがkillイベントを受信すると、SIGTERMシグナルがタスクに送信され、kill処理が開始されます。タスクの動作によっては、この信号だけでタスクを終了させることができます。タスクによっては、このシグナルを使って、時間をかけてグレースフル・ターミネーションのプロセスを開始するものもあります。ある程度の遅延の後、SIGKILLシグナルがタスクに送信され、タスクがまだ実行中であれば強制的に終了させます。SIGTERMシグナルとSIGKILLシグナルの間の遅延は、タスクのkill grace periodの長さによって決まります。タスクに猶予期間が設定されていない場合は、数秒のデフォルト値が使用されます。

## ノードでのドレインを開始する
エージェントのドレインを開始するには、マスターに対してoperator API [DRAIN_AGENTコール](operator-http-api.md#drain_agent)を発行します。:

    $ curl -X POST -d '{"type": "DRAIN_AGENT", "drain_agent": {"agent_id": {"value": "<mesos-agent-id>"}}}' masterhost:5050/api/v1

これにより、エージェントのすべてのタスクを停止する処理が直ちに開始されます。一度開始されたドレイン処理はキャンセルできません。ドレイン処理の進行状況を監視するには、マスター・オペレーターAPIの[`GET_STATE`](operator-http-api.md#get_state)または[`GET_AGENTS`](operator-http-api.md#get_agents)コールでエージェントの状態を調べることができます。:

    $ curl -X POST -d '{"type": "GET_AGENTS"}' masterhost:5050/api/v1

関連するエージェントを見つけ、その `drain_info.state` フィールドを検査します。ドレイン中、状態は`DRAINING`になります。エージェント上のすべてのタスクが終了し、それらのすべてのターミナル・ステータス・アップデートがスケジューラによって承認され、エージェント上のすべてのオファー操作が終了すると、ドレインが完了し、エージェントのドレイン状態は`DRAINED`に移行します。この時点で、ノードはメンテナンスのために停止することができます。

## 自動ノードドレインのオプション
ドレインの際に`max_grace_period`オプションを指定することで、ドレインタスクのキルグレース期間に上限を設定することができます。:

    $ curl -X POST -d '{"type": "DRAIN_AGENT", "drain_agent": {"agent_id": {"value": "<mesos-agent-id>"}, "max_grace_period": "10mins"}}' masterhost:5050/api/v1

ドレイン中のノードがドレイン完了後に戻ってこないことがわかっていて、そのノードを自動的にクラスタから永久に削除したい場合は、`mark_gone`オプションを指定することができます。:

    $ curl -X POST -d '{"type": "DRAIN_AGENT", "drain_agent": {"agent_id": {"value": "<mesos-agent-id>"}, "mark_gone": true}}' masterhost:5050/api/v1

これは、例えば、オートスケールされたクラウドインスタンスの場合、インスタンスがスケールダウンされ、二度と戻ってこないような場合に役立ちます。これは、エージェントのドレインが終了した直後に[`MARK_AGENT_GONE`](operator-http-api.md#mark_agent_gone)コールを発行することと同じです。警告：`mark_gone`オプションを使用したドレインは不可逆的であり、エージェントノード上のすべてのローカル永続的データが失われます。このオプションの使用には注意が必要です。

## メンテナンス後のノードの再起動

エージェントのメンテナンスが完了したら、マスターに再登録してクラスタに再参加できるように、エージェントを再起動する必要があります。これを行うには、マスター・オペレーターAPIの[`REACTIVATE_AGENT`](operator-http-api.md#reactivate_agent)コールを使用できます。:

    $ curl -X POST -d '{"type": "REACTIVATE_AGENT", "reactivate_agent": {"agent_id": {"value": "<mesos-agent-id>"}}}' masterhost:5050/api/v1

# `Manual Node Draining`

ドレインプロセスをより細かく制御する必要がある場合は、Mesos オペレータ API と、エージェント上でタスクを実行しているスケジューラが公開している API の両方を使用して、エージェントを手動でドレインすることができます。

## エージェントの無効化

手動ドレイン処理の最初のステップは、対象となるエージェントで新しいタスクが起動しないようにするエージェントの無効化です。:

    $ curl -X POST -d '{"type": "DEACTIVATE_AGENT", "deactivate_agent": {"agent_id": {"value": "<mesos-agent-id>"}}}' masterhost:5050/api/v1

`200 OK` レスポンスを受け取った場合、エージェントは非活性化されています。エージェントの非活性化状態は、マスター・オペレーターAPIの[`GET_STATE`](operator-http-api.md#get_state)または[`GET_AGENTS`](operator-http-api.md#get_agents)コールのレスポンスにある`deactivated`フィールドを確認することで確認することができます。エージェントが非活性化されると、エージェント上で実行されているタスクを担当するスケジューラが公開している API を使用して、それらのタスクを手動で強制終了することができます。エージェント上のすべてのタスクが終了し、それらのターミナル・ステータス・アップデートがスケジューラによって認識されたことを確認するには、[`GET_TASKS`](operator-http-api.md#get_tasks-1) エージェント・オペレータ API コールに対するレスポンスの `pending_tasks`、`queued_tasks`、および `launched_tasks` フィールドが空であることを確認します。:

    $ curl -X POST -d '{"type": "GET_TASKS"}' agenthost:5051/api/v1

ターゲットエージェント上のネットワークストレージでバックアップされたボリュームを使用している場合、エージェント上で長時間実行されているオファー操作がまだ終了していない可能性があります。これを確認するには、エージェントに対してエージェントオペレータAPIの[`GET_OPERATIONS`](operator-http-api.md#get_operations-1)コールを発行します。:

    $ curl -X POST -d '{"type": "GET_OPERATIONS"}' agenthost:5051/api/v1

`latest_status`に`OPERATION_PENDING`が指定されている操作がある場合は、その操作が終了するのを待ってからノードを停止する必要があります。残念ながら、このようなストレージ操作をキャンセルしたり強制的に終了させたりすることはできません。このような操作が保留状態で止まってしまった場合は、関連するストレージバックエンドに問題がないか検査する必要があります。

エージェント上のすべてのタスクが終了し、すべてのオファー操作が終了すると、メンテナンスのためにノードを停止することができます。メンテナンスが完了したら、ノードを再起動する手順は、ノードの`Automatic Node Draining`のセクションで説明したものと同じです。

# `Maintenance Primitives`

フレームワークは、サービスレベルアグリーメントを満たすため、またはエンドユーザーにサービスを中断させないために、クラスターの運用を中断させる行為を可視化する必要があります。したがって、フレームワークとオペレータの要求を両立させるためには、フレームワークは計画されたメンテナンスイベントを認識し、オペレータはフレームワークのメンテナンスへの適応能力を認識する必要があります。メンテナンスプリミティブは、フレームワークとオペレータの間のコミュニケーションを促進するためのレイヤーを追加します。

## 用語の解説

このセクションでは、「オペレーター」とは、Mesosクラスタを管理する人、ツール、またはスクリプトのことです。

Maintenance primitivesは、Mesosにいくつかの新しい概念を追加します。それらの概念は:

* **Maintenance**: マシン上のリソースを一時的または恒久的に利用できなくする操作のこと。
* **Maintenance window**: 一連のマシンと、それらのマシンに対して何らかのメンテナンスが計画されている時間間隔。
* **Maintenance schedule**: メンテナンスウィンドウのリストです。1台のマシンがスケジュールに表示されるのは1回だけです。
* **Unavailability**: 関連するマシンが利用できなくなる可能性のある、開始時間と継続時間によって定義される、オペレータが指定した間隔。一般的に、利用不能になった後のマシン（またはリソース）の利用可能性については仮定してはならない。
* **Drain**: メンテナンスが予定されてから、マシンが利用できなくなるまでの間隔。ドレインされたマシンのリソースを使って送られたオファーには、使用不能の情報が含まれます。ドレインされたマシン上で稼働しているフレームワークは、逆のオファーを受け取ることになります（次項参照）。影響を受けるマシンのリソースを利用しているフレームワークは、利用不能に備えて先手を打つか、フレームワークがメンテナンススケジュールに従えないことを伝えることが期待されます。
* **Inverse offer**: マスターがフレームワークにリソースの返却を求めるための通信メカニズム。これにより、利用できない場合はフレームワークに通知され、フレームワークはそれに応じることができるかどうかを回答するためのメカニズムが与えられます。逆オファーは、オファーと同様に、受け入れ、拒否し、再オファーし、取り消すことができます。

**注:** アンアベイラビリティとインバースオファーは、メンテナンスに特有のものではありません。同じコンセプトは、リソースの再割り当てやリソースの先取りなど、メンテナンス以外の目的にも使用することができます。

## どのような仕組みになっているのでしょうか？
Mesos 0.25.0で`Maintenance primitives`が導入されました。また、いくつかのマシンメンテナンスモードが導入されました。それらのモードを以下に説明します。

![Maintenance mode transitions](images/maintenance-primitives-modes.png)

すべてのモード移行は、オペレータが開始する必要があります。Mesosは、メンテナンススケジュールで提示された見積もりに関わらず、どのマシンのモードも変更しません。

### メンテナンスのスケジューリング

マシンは、メンテナンスが予定されるとすぐにUpモードからDrainingモードに移行します。マシンをDrainingモードに移行させるために、オペレーターはメンテナンススケジュールをJSONドキュメントとして作成し、Mesosマスターの[/maintenance/schedule](endpoints/master/maintenance/schedule.md) HTTPエンドポイントに投稿します。各Mesosクラスターには1つのメンテナンススケジュールがあり、新しいスケジュールを投稿すると、以前のスケジュールがある場合は置き換えられます。

[maintenance::Schedule](https://github.com/apache/mesos/blob/016b02d7ed5a65bcad9261a133c8237c2df66e6e/include/mesos/maintenance/maintenance.proto#L48-L67)の定義と[Unavailability](https://github.com/apache/mesos/blob/016b02d7ed5a65bcad9261a133c8237c2df66e6e/include/mesos/v1/mesos.proto#L140-L154)の定義を参照してください。

本番環境では、フレームワークによるサービスが中断されないように、任意の時点で十分な数のエージェントが稼働するようにスケジュールを構築する必要があります。

例えば、3台のマシンからなるクラスタの場合、オペレータは2台のマシンに1時間のメンテナンスを行い、最後のマシンにはさらに1時間のメンテナンスを行うようにスケジュールすることができます。使用不可のタイムスタンプはUnixエポックからのナノ秒で表されます（メンテナンスプリミティブを確実に使用するには、クラスタ内のすべてのマシンのシステムクロックがほぼ同期している必要があることに注意してください）。

スケジュールは以下のようになります。:

```
{
  "windows" : [
    {
      "machine_ids" : [
        { "hostname" : "machine1", "ip" : "10.0.0.1" },
        { "hostname" : "machine2", "ip" : "10.0.0.2" }
      ],
      "unavailability" : {
        "start" : { "nanoseconds" : 1443830400000000000 },
        "duration" : { "nanoseconds" : 3600000000000 }
      }
    }, {
      "machine_ids" : [
        { "hostname" : "machine3", "ip" : "10.0.0.3" }
      ],
      "unavailability" : {
        "start" : { "nanoseconds" : 1443834000000000000 },
        "duration" : { "nanoseconds" : 3600000000000 }
      }
    }
  ]
}
```
オペレーターは、マスターの[/maintenance/schedule](endpoints/master/maintenance/schedule.md)エンドポイントにスケジュールを投稿することができます。:

```
curl http://localhost:5050/maintenance/schedule \
  -H "Content-type: application/json" \
  -X POST \
  -d @schedule.json
```

メンテナンススケジュールに登録されているマシンは、スケジュール設定時にMesosマスターに登録されている必要はありません。オペレータは、マシン上でエージェントを起動する前に、マシンをメンテナンス・スケジュールに追加することができる。例えば、故障したマシンが起動時にエージェントを起動するのを防ぐのに有効である。

**注:** メンテナンススケジュールの各マシンには、できるだけ完全な情報が必要です。Mesosがエージェントを特定のマシンからのものと認識するためには、`hostname`と`ip`の両フィールドが一致する必要がある。省略されたデータは、空の文字列「"」がデフォルトとなります。1 台のマシンに複数のホスト名または IP がある場合、マシンのフィールドは、エージェントがマスターにアナウンスする内容と一致している必要があります。マシンの設定に曖昧さがある場合、オペレータはエージェントの起動時に`--hostname`および`--ip`オプションを使用する必要がある。

マスターは、メンテナンススケジュールが以下のプロパティを持つことをチェックする。:

* スケジュールの各メンテナンスウィンドウには、少なくとも1台のマシンと指定された使用不可期間が必要です。
* 各マシンは、スケジュールに一度だけ表示されなければならない。
* 各マシンには、少なくともホスト名またはIPが含まれていなければならない。ホスト名は大文字と小文字を区別しない。
* ダウンモードにあるすべてのマシンがスケジュールに含まれていなければならない。これは、このエンドポイントがDownモードからUpモードへの移行を処理しないために必要である。

これらのプロパティのいずれかが満たされていない場合、メンテナンススケジュールは、対応するエラーメッセージとともに拒否され、マスターの状態は変更されません。

メンテナンス・スケジュールを更新するには、オペレーターはまず現在のスケジュールを読み、必要な変更を加えた後、変更後のスケジュールを投稿する必要があります。現在のメンテナンススケジュールは、マスターの`/maintenance/schedule`エンドポイントにGETリクエストを送信することで取得できます。

メンテナンス・スケジュールをキャンセルするには、オペレータは空のスケジュールを投稿する必要があります。

### ドレインモード

スケジュールがMesos masterに投稿されると、次のようなことが起こります。:

* スケジュールは[replicated log](replicated-log-internals.md)に保存されます。これは、マスターがフェイルオーバーした場合でも、スケジュールが持続されることを意味します。
* スケジュールに含まれるすべてのマシンは、即座にDrainingモードに移行します。各マシンのモードもレプリケートされたログに保存されます。
* 影響を受けたエージェントのリソースを使用しているすべてのフレームワークに、直ちに通知されます。影響を受けたエージェントからの既存のオファーは取り消され、利用できないデータを追加して再送信されます。影響を受けたエージェントのリソースを使用しているすべてのフレームワークには、逆のオファーが与えられます。
* 影響を受けたエージェントからの新しいオファーには、追加の利用不可データが含まれます。

フレームワークは、この追加情報を利用して、メンテナンスを考慮した形でタスクをスケジューリングする必要があります。具体的な方法は、各スケジューラの設計要件に依存しますが、通常、タスクは、利用率を最大化すると同時に、マシンの広告された利用不能期間が発生する前にマシンを空けるようにスケジュールされるべきです。スケジューラは、長時間稼働するタスクを利用不能のないマシンに配置するか、利用不能が最も遠いマシンに配置するかを選択することができます。

フレームワークが逆オファーにどのように反応するかは、メンテナンススケジュールに適合する能力を示します。逆オファーを受け入れることは、フレームワークのリソースの現在の状態を考慮して、フレームワークが現在のメンテナンススケジュールで問題ないことを伝える。マスターとオペレーターは、逆オファーに含まれるすべてのリソースを利用不可区間の開始前に解放するというフレームワークによる最善の努力の約束として、受け入れを解釈すべきである。逆オファーを辞退することは、フレームワークがメンテナンス・スケジュールを満たすことができない、またはできそうにないことをオペレータに勧告することである。

例えば、以下のようになります。:

* データストアは、そのエージェントの1つがメンテナンスを予定している場合、新しいレプリカを開始することを選択することができます。データストアは、逆オファーに記載されている利用不能期間が始まる前に、マシン上のデータを新しいホストに合理的にコピーできる場合は、逆オファーを受け入れるべきです。それ以外の場合は、データストアはその申し出を断るべきです。
* 利用不能が迫っているエージェント上のステートフル・タスクは、利用可能な別のエージェントに移行することができる。フレームワークがそうするための十分なリソースを持っていれば、逆オファーを受け入れるだろう。そうでなければ、それを拒否するだろう。

フレームワークは、フィルターを使用して、逆オファーで再度連絡を受けたいタイミングを制御することができます。これは、将来の状況によってメンテナンススケジュールの実行可能性が変わる可能性があるため、有用です。逆オファーのフィルタは、フレームワークにオファーを再提示する既存のメカニズムと同じです。

**注:** 逆オファーを受け入れたり辞退したりしても、メンテナンススケジュールやMesosの動作方法がすぐに変更されるわけではありません。逆オファーは、フレームワークが有用と考える追加情報を示すだけです。同じように、逆オファーを拒否または受け入れることは、オペレーターにとってのヒントです。オペレータは、そのヒントを考慮するかどうかを選択できます。

### メンテナンスの開始
オペレーターは、[/machine/down](endpoints/master/machine/down.md) HTTPエンドポイントにマシンのリストを投稿することで、メンテナンスを開始します。マシンのリストは、JSON形式で指定され、リストの各要素は[MachineID](https://github.com/apache/mesos/blob/016b02d7ed5a65bcad9261a133c8237c2df66e6e/include/mesos/v1/mesos.proto#L157-L167)となります。

例えば、2台のマシンのメンテナンスを開始する場合:

```
[
  { "hostname" : "machine1", "ip" : "10.0.0.1" },
  { "hostname" : "machine2", "ip" : "10.0.0.2" }
]
```

```
curl http://localhost:5050/machine/down \
  -H "Content-type: application/json" \
  -X POST \
  -d @machines.json
```

マスターは、マシンのリストが以下のプロパティを持っていることを確認します。:
* マシンのリストは空であってはなりません。
* 各マシンは一度だけ表示されなければなりません。
* 各マシンには、少なくともホスト名またはIPが含まれていなければなりません。ホスト名は大文字と小文字を区別しません。
* マシンのIPが含まれる場合、正しく形成されていなければなりません。
* リストアップされたすべてのマシンは、スケジュールに存在しなければなりません。

これらのプロパティのいずれかが満たされていない場合、その操作は対応するエラーメッセージとともに拒否され、マスターの状態は変更されません。

オペレーターは、メンテナンスが予定されているすべてのマシンのメンテナンスを開始することができます。メンテナンスが予定されていないマシンは、アップモードからダウンモードに直接移行することはできない。しかし、オペレータは、現在の時刻または過去の時刻に等しいタイムスタンプを持つマシンをメンテナンスのためにスケジュールし、そのマシンのメンテナンスを直ちに開始することができる。

このエンドポイントは、現在Mesosマスターに登録されていないマシンのメンテナンスを開始するために使用できる。これは、マシンに障害が発生し、オペレーターがそのマシンをクラスターから削除しようとしている場合に役立ちます。マシンのメンテナンスを開始することで、そのマシンが誤って再起動され、Mesosクラスターに再参加することを防ぐことができます。

オペレータは、マシンをDrainingモードからDownモードに明示的に移行させる必要があります。つまり、Mesosは、利用不能ウィンドウが到着または通過しても、マシンをDrainingモードに保つ。つまり、マシンの動作は一切中断されず、このマシンに対して（利用不可情報を含む）オファーが送信されたままになります。

オペレーターによってメンテナンスがトリガーされると、マシン上のすべてのエージェントはシャットダウンするように指示されます。これらのエージェントはマスターから削除されます。つまり、これらのエージェント上で実行されているすべてのタスクに対して、`TASK_LOST`ステータスアップデートが送信されます。スケジューラドライバの`slaveLost`コールバックも、削除された各エージェントに対して実行されます。また、メンテナンス中のマシン上のエージェントは、メンテナンスが完了してマシンが復旧するまで、マスターへの再登録ができなくなります。

### メンテナンスの完了
メンテナンスが完了した場合、またはメンテナンスをキャンセルする必要がある場合、オペレーターはメンテナンスを停止することができます。このプロセスは、メンテナンスの開始と非常によく似ています（前のセクションと同じ検証基準）。オペレーターは、マスターの[/machine/up](endpoints/master/machine/up.md)エンドポイントにマシンのリストを投稿します。:

```
[
  { "hostname" : "machine1", "ip" : "10.0.0.1" },
  { "hostname" : "machine2", "ip" : "10.0.0.2" }
]
```

```
curl http://localhost:5050/machine/up \
  -H "Content-type: application/json" \
  -X POST \
  -d @machines.json
```
**注:** メンテナンススケジュールの "unavailability "フィールドで示されるメンテナンスウィンドウの期間は、オペレーターによる最善の推測である。利用不可期間の終了前にメンテナンスを停止することも、利用不可期間の終了後にメンテナンスを停止することも可能です。マシンが自動的にメンテナンス終了に移行することはありません。

フレームワークは、そのマシンからのオファーが送信され始めたときに、メンテナンスの完了またはキャンセルについて通知されます。メンテナンスが終了したことをフレームワークに通知する明示的なメカニズムはありません。メンテナンスが終了すると、新しいオファーに利用不可のタグが付けられなくなり、逆オファーも送信されなくなります。また、そのマシン上で実行されているエージェントは、Mesosマスターへの登録が許可されます。

### メンテナンス状況の確認
クラスタ内の各マシンの現在のメンテナンス状態（Up、Draining、Down）は、マスターの[/maintenance/status](endpoints/master/maintenance/status.md) HTTPエンドポイントにアクセスすることで確認できます。ドレイン中の各マシンについて、このエンドポイントには、そのマシン上のリソースに対する逆オファーに対するフレームワークの応答も含まれます。詳細については、[ClusterStatus message](https://github.com/apache/mesos/blob/fa36917dd142f66924c5f7ed689b87d5ceabbf79/include/mesos/maintenance/maintenance.proto#L73-L84)のフォーマットを参照してください。

The current maintenance status (Up, Draining, or Down) of each machine in the
cluster can be viewed by accessing the master's
[/maintenance/status](endpoints/master/maintenance/status.md) HTTP endpoint. For
each machine that is Draining, this endpoint also includes the frameworks' responses to
inverse offers for resources on that machine. For more information, see the
format of the [ClusterStatus message](https://github.com/apache/mesos/blob/fa36917dd142f66924c5f7ed689b87d5ceabbf79/include/mesos/maintenance/maintenance.proto#L73-L84).

>注: このエンドポイントが返すデータのフォーマットは、Mesosの将来のリリースで変更される可能性があります。
