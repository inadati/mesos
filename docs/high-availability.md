---
title: Apache Mesos - High-Availability Mode
layout: documentation
---

# Mesosの高可用モード

Mesosマスターが利用できない場合、既存のタスクは継続して実行できますが、新しいリソースの割り当てや新しいタスクの起動はできません。このような事態が発生する可能性を減らすために、Mesosには複数のMesosマスターを使用する高可用モードがあります。各マスターはリーダーを選出し、[Apache ZooKeeper](http://zookeeper.apache.org/)がその調整と、マスター、エージェント、スケジューラドライバによるリーダーの検出を行います。[リーダー選挙の仕組み](https://zookeeper.apache.org/doc/current/recipes.html#sc_leaderElection)については、Apache ZookeeperのWebサイトを参照してください。

このドキュメントでは、Mesosが高可用モードで動作するように設定する方法を説明します。高可用性フレームワークの開発に関する詳細は、[関連文書](high-availability-framework-guide.md)を参照してください。

**注**: 本ドキュメントは、Mesosの標準ビルドに含まれるクライアント・ライブラリであるZooKeeperの起動、実行、および操作方法を知っていることを前提としています。

## 使用方法
Mesosを高可用モードにするには:

1. ZooKeeperクラスタが稼働していることを確認します。

2. znodeパスを全てのマスター、エージェント、フレームワーク・スケジューラーに以下のように提供します。:

    * `--zk=zk://host1:port1,host2:port2,.../path`のように、`--zk`フラグを使ってmesos-masterのバイナリを起動します。

    * mesos-agentのバイナリを`--master=zk://host1:port1,host2:port2,.../path`で起動します。

    * 前の2つのステップと同じzkパスを使用して、任意のフレームワークのスケジューラを起動します。[フレームワーク開発ガイド](app-framework-development-guide.md)にあるように、SchedulerDriverはこのパスで構築する必要があります。

これ以降、MesosのマスターとエージェントはすべてZooKeeperと通信し、どのマスターが現在のリーディングマスターであるかを調べます。これは、リーディングマスターとエージェント間の通常の通信に加えて行われます。

ZooKeeper以外にも、任意のマスターの[/redirect](endpoints/master/redirect.md)エンドポイントにHTTPリクエストを送ることで、リーディングマスターの位置を知ることができます。

リーディングマスターでのみ動作するHTTPエンドポイントの場合、リーディングマスターでないマスターのエンドポイントへのリクエストは、`307 Temporary Redirect` (リーディングマスターの位置を示す)または`503 Service Unavailable` (マスターが現在のリーダーを知らない場合)のいずれかになります。

リーダーの変更に対処する方法については、[Scheduler API](app-framework-development-guide.md)を参照してください。

## コンポーネントの切断処理
ネットワークパーティションがコンポーネント(マスター、エージェント、スケジューラドライバ)をZooKeeperから切り離すと、コンポーネントのマスター検出器はタイムアウトイベントを発生させる。これにより、コンポーネントはリードするマスターがいないことを通知します。コンポーネントによっては、以下のようになる。(コンポーネントがZooKeeperから切断されている間も、マスターはエージェントやスケジューラと通信している可能性があり、その逆もまた然りであることに注意)

* ZooKeeperから切り離されたエージェントは、どのマスターがリーダーなのか分からなくなりました。エージェントは、リーダーではないマスターの判断で行動しないように、マスターからのメッセージを無視する。エージェントがZooKeeperに再接続すると、ZooKeeperは現在のリーダを通知し、エージェントはリーダーからのメッセージを無視しなくなる。

* マスターは、切断前にリーダーであったかどうかに関わらず、リーダーレス状態になります。

    * リーダーがZooKeeperから切断された場合、その処理を中止する。ユーザ/開発者/管理者は、ZooKeeperに再接続しようとする新しいマスター・インスタンスを起動することができる。
      * なお、Mesosの多くのプロダクションデプロイメントでは、プロセスが予期せず中止された場合にMesosマスターを自動的に再起動するように設定されたプロセススーパーバイザー（systemdやsupervisordなど）が使用されています。

    * そうでなければ、切断されたバックアップはZooKeeperとの再接続を待ち、新しいリーディングマスターに選出される可能性がある。

* リーディングマスターから切断されたスケジューラーのドライバーは、リーディングマスターからの切断をスケジューラーに通知します。

ネットワーク・パーティションによってエージェントがリーダーから切り離されると:

* エージェントは、リーダーからのヘルスチェックに失敗します。

* リーダーは、エージェントを停止したと判断し、そのタスクをLOST状態に送ります。[フレームワーク開発ガイド](app-framework-development-guide.md)では、これらの様々なタスクの状態について説明しています。

* 一度停止したエージェントは、リーダーに再登録することはできず、停止後の連絡の際にはシャットダウンするように言われます。

## 監視
クォーラムを形成するために相互に通信しているクラスタ内のマスターの現在の数を監視するには、監視ガイドの`registrar/log/ensemble_size`の[Replicated Log](monitoring.md#replicated-log)を参照してください。リーダー選出の失敗をカバーするアラートを作成するには、モニタリングガイドの`master/elected`の[Basic Alerts](monitoring.md#basic-alerts)を参照してください。

## 実装の詳細
Mesosは2段階のZooKeeperリーダー選挙の抽象化を実装しています。1つは`src/zookeeper`に、もう1つは`src/master`にあります。（`contender|detector.hpp|cpp`を参照してください）

* 下位の`LeaderContender`と`LeaderDetector`は、ZooKeeperの一般的な選挙アルゴリズムを実装する (マスターグループのサイズが3と小さいため、群れの影響を処理していない→[詳しくは](http://zookeeper.apache.org/doc/current/recipes.html#sc_leaderElection))。

* 上位の`MasterContender`と`MasterDetector`は、ZooKeeperのコンテンダーとディテクターの抽象化を、ZooKeeperのデータを提供/解釈するアダプタとして実装する。

* 各Mesosマスターは、コンテンダーとディテクターの両方を同時に使用して、自分自身を選出し、現在のリーダーが誰であるかを検出しようとする。各マスターのWebUIは、そのマスターが選出されていない場合、ブラウザのトラフィックを現在のリーダーにリダイレクトするため、別の検出器が必要です。他のMesosコンポーネント（エージェントやスケジューラドライバなど）は、ディテクターを使用して現在のリーダーを見つけ、そこに接続します。

リーダー候補のグループという概念はGroupで実装されている。この抽象化は、(キューとカバー下の再試行可能なエラーによる)信頼性の高い ZooKeeper グループメンバーシップの登録、キャンセル、監視を行う。いくつかのZooKeeperセッションイベントを監視する。:

* 接続
* 再接続
* セッションの有効期限
* ZNodeの作成、削除、更新

また、ZooKeeperとの接続が切れたときには、セッションを明示的にタイムアウトさせます。設定オプション `--zk_session_timeout` を参照。これは、ZooKeeperクライアントライブラリは再接続時にのみセッションの失効を通知するからです。これらのタイムアウトはネットワーク・パーティションの場合に特に注意が必要です。
