---
title: Apache Mesos - Authentication
layout: documentation
---

# 認証

認証により、信頼できるエンティティのみがMesosクラスターと対話することができます。認証は、Mesosでは3つの方法で使用できます。

1. フレームワークをマスターに登録する際に、認証を必要とすること。
2. マスターに登録するために、エージェントの認証を必要とする。
3. 多くの[HTTPエンドポイント](endpoints/index.md)を使用するために、オペレーターの認証を必要とすること。

認証はデフォルトでは無効です。認証を有効にすると、オペレータは、デフォルトの認証モジュールを使用するか、カスタムの認証モジュールを使用するようにMesosを設定できます。

デフォルトのMesos認証モジュールは、[Cyrus SASL](http://asg.web.cmu.edu/sasl/)ライブラリを使用します。SASLは、2つのエンドポイントがさまざまな方法で相互に認証できるようにする柔軟なフレームワークです。デフォルトでは、Mesosは[CRAM-MD5](https://en.wikipedia.org/wiki/CRAM-MD5)認証を使用します。

## クレデンシャル、プリンシパル、およびシークレット
デフォルトのCRAM-MD5認証方式を使用する場合、Mesosでの認証を希望するエンティティは、プリンシパルとシークレットで構成されるクレデンシャルを提供する必要があります。プリンシパルは、エンティティが使用するIDであり、シークレットは、そのIDを検証するために使用される任意の文字列です。プリンシパルはユーザ名に似ており、シークレットはパスワードに似ている。

プリンシパルは、主に認証と[認可](authorization.md)に使用されます。プリンシパルは、フレームワークのユーザー（エージェントがエグゼキュータを実行するために使用するオペレーティング・システム・アカウント）やフレームワークの[ロール](roles.md)（フレームワークがどのリソースを使用できるかを決定するために使用される）とは異なることに注意してください。

## 設定
認証の設定は、Mesosマスターおよびエージェントプロセスの起動時にコマンドラインフラグを指定して行います。詳細については、[設定](configuration.md)ドキュメントを参照してください。

### Master
* `--[no-]authenticate` - `true` の場合、認証されたフレームワークのみが登録可能となります。`false`（デフォルト）の場合は、認証されていないフレームワークも登録できます。

* `--[no-]authenticate_http_readonly` - `true`の場合、認証をサポートする読み取り専用のHTTPエンドポイントへのHTTPリクエストには認証が必要です。`false`（デフォルト）の場合、これらのエンドポイントは、認証なしで使用できます。読み取り専用のエンドポイントとは、クラスタの状態を変更するために使用できないものです。

* `--[no-]authenticate_http_readwrite` - `true`の場合、認証をサポートする読み書き両用のHTTPエンドポイントへのHTTPリクエストに認証が必要です。`false`（デフォルト）の場合、これらのエンドポイントは認証なしで使用できます。読み書き可能なエンドポイントは、クラスタの状態を変更するために使用できるものです。

* `--[no-]authenticate_agents` - `true`の場合、認証されたエージェントのみが登録できます。`false`(デフォルト)の場合、認証されていないエージェントも登録できます。

* `--authentication_v0_timeout` - v0フレームワークまたはエージェントに対して認証が完了するまでのタイムアウトです。これは、v0またはv1のHTTP APIには適用されません（デフォルト：`15秒`）。

* `--authenticators` - 使用する認証モジュールを指定します。デフォルトは`crammd5`ですが、`--modules`オプションを使用して追加モジュールを追加できます。

* `--http_authenticators` - 使用するHTTP認証モジュールを指定します。デフォルトは basic（基本的な HTTP 認証）ですが、 `--modules` オプションを使って追加モジュールを追加することができます。

* `--credentials` - 受け入れられる認証情報のリストを含むテキストファイルへのパスです。使用する認証モジュールによってはオプションとなります。

### Agent
* `--authenticatee` - マスターの `--authenticators` オプションと同じで、使用するモジュールを指定します。デフォルトでは`crammd5`が使用されます。

* `--credential` - マスターの `--credentials` オプションと同様ですが、1つのクレデンシャルしか許可されません。このクレデンシャルは、マスターに対するエージェントの識別に使用されます。

* `--[no-]authenticate_http_readonly` - `true`の場合、認証をサポートする読み取り専用のHTTPエンドポイントへのHTTPリクエストには認証が必要です。`false`（デフォルト）の場合、これらのエンドポイントは認証なしで使用できます。読み取り専用エンドポイントとは、エージェントの状態を変更するために使用できないエンドポイントのことです。

* `--[no-]authenticate_http_readwrite` - `true`の場合、認証をサポートする読み書き可能なHTTPエンドポイントへのHTTPリクエストには認証が必要です。`false`（デフォルト）の場合、これらのエンドポイントは認証なしで使用できます。読み書き可能なエンドポイントとは、エージェントの状態を変更するために使用できるものです。後方互換性の理由から、V1エクゼキュータAPIはこのフラグの影響を受けないことに注意してください。

* `--[no-]authenticate_http_executors` - `true`の場合、V1エクゼキュータAPIへのHTTPリクエストには認証が必要です。`false`（デフォルト）の場合、そのAPIは認証なしで使用できます。このフラグが`true`で、カスタムHTTP認証子が指定されていない場合は、デフォルトの`JWT`認証子がロードされ、エクゼキュータ認証を処理します。

* `--http_authenticators` - 使用する HTTP 認証モジュールを指定します。デフォルトは`basic`ですが、`--modules` オプションを使用してモジュールを追加することができます。

* `--http_credentials` - 受け入れられる認証情報のリスト（JSON形式）を含むテキストファイルへのパスです。これは使用する認証機関によってはオプションとなります。

* `--authentication_backoff_factor` - エージェントは、指数関数的なバックオフに基づいて、マスターとの認証のタイムアウトを行います。タイムアウトは、`[min, min + factor*2^n]`の範囲でランダムに選択されます（`n`は失敗した試行回数）。これらのパラメータを調整するには、`--authentication_timeout_[min|max|factor]`フラグを設定します。(デフォルト: 1secs)

* `--authentication_timeout_min` - エージェントがマスターとの認証を再試行するまでの最小待機時間です。詳細は `--authentication_backoff_factor` を参照してください。(デフォルト: 5secs)

* `--authentication_timeout_max` - マスターとの認証を再試行するまでのエージェントの最大待機時間です。詳細は `--authentication_backoff_factor` を参照してください。(デフォルト: 1mins)

### スケジューラードライバー
* `--authenticatee` - マスターの `--authenticators` オプションと同じで、使用するモジュールを指定します。デフォルトでは`crammd5`が使用されます。

* `--authentication_backoff_factor` - スケジューラは、指数関数的なバックオフに基づいて、マスターとの認証のタイムアウトを行います。タイムアウトは、`[min, min + factor*2^n]`の範囲内でランダムに選択されます（`n`は失敗した試行回数）。これらのパラメータを調整するには、`--authentication_timeout_[min|max|factor]`フラグを設定します。(デフォルト: 1secs)

* `--authentication_timeout_min` - スケジューラがマスターとの認証を再試行するまでの最小待機時間です。詳細は `--authentication_backoff_factor` を参照してください。(デフォルト: 5secs)

* `--authentication_timeout_max` - スケジューラーがマスターとの認証を再試行するまでの最大待機時間です。詳細は `--authentication_backoff_factor` を参照してください。(デフォルト: 1mins)

### 複数のHTTP認証機能
複数のHTTP認証子をMesosマスターとエージェントにロードすることができます。複数の認証子をロードするには、`--http_authenticators` フラグを使用して、カンマ区切りのリストとして指定します。認証子は連続して呼び出され、最初に成功した認証の結果が返されます。

カスタム認証モジュールに加えて、デフォルトのベーシック HTTP 認証モジュールを指定する場合は、認証モジュールのリストに `basic` という名前を追加します。カスタム認証モジュールに加えて、デフォルトの JWT HTTP 認証モジュールを指定する場合は、`jwt` という名前を認証モジュールリストに追加します。

### エグゼキューター
エージェントでHTTPエクゼキュータ認証が有効になっている場合、HTTPエクゼキュータからのすべてのリクエストは認証されなければなりません。これには、デフォルトのエクゼキュータ、HTTP コマンドエクゼキュータ、およびカスタム HTTP エクゼキュータが含まれます。デフォルトでは、エージェントの JSON Web Token (JWT) HTTP 認証機能が、エクゼキュータとオペレーターの API エンドポイントの両方でエクゼキュータ認証を処理するためにロードされます。HTTP API を使用しないコマンドおよびカスタムエクゼキュータは、認証されないままです。

`--jwt_secret_key` フラグで秘密鍵がロードされると、エージェントは起動前に各エクゼキュータ用のデフォルト JWT を生成します。このトークンは、環境変数`MESOS_EXECUTOR_AUTHENTICATION_TOKEN`を介してエクゼキュータの環境に渡されます。エージェントで認証するために、エクゼキュータはこのトークンをすべてのリクエストの`Authorization`ヘッダに以下のように配置する必要があります。

        Authorization: Bearer MESOS_EXECUTOR_AUTHENTICATION_TOKEN

既存のクラスターをアップグレードしてエクゼキュータ認証を必要とするようにするには、以下の手順を踏む必要があります。
1. すべてのエージェントをアップグレードし、各エージェントに `--jwt_secret_key` フラグで暗号鍵を提供します。この鍵は、HMAC-SHA256 方式で実行者認証トークンに署名するために使用されます。

2. 実行者認証を有効にするには、すべての HTTP 実行者が実行者認証トークンを持ち、認証をサポートする必要があります。そのためには、アップグレード前にすでに稼働していたエクゼキュータを再起動する必要があります。この作業は一度に行うこともできますし、クラスタを中間的な状態にしておいてエクゼキュータが徐々に切り替わるようにすることもできます。

3. アップグレードされたエージェントによって、稼働中のデフォルト／HTTP コ マンド・エクゼキュータがすべて起動され、カスタム HTTP エクゼキュータもアップグレー ドされたら、`--authenticate_http_executors` フラグを設定してエージェント・ プロセスを再起動できます。これにより、必要な HTTP エグゼキュータの認証が有効になり、すべてのエグゼキュータが認証トークンを持ち、認証をサポートするようになったため、エージェントへのリクエストが正常に認証されるようになります。

HTTP エグゼキュータは、ネストされたコンテナ呼び出しを行うために、エージェントオペレータ API を使用します。つまり、HTTPエクゼキュータの認証を無効にしているときに、(`--authenticate_http_readwrite`で)v1エージェントオペレータAPIの認証を有効にすると、HTTPエクゼキュータが正常に動作しなくなります。

### フレームワーク
フレームワーク認証を有効にした場合、Mesosマスターに登録する際に認証情報を提供するように各フレームワークを設定する必要があります。この設定方法はフレームワークによって異なりますので、詳細はフレームワークのドキュメントを参照してください。

フレームワークの開発者にとって、認証のサポートは簡単です。スケジューラドライバは、そのコンストラクタに`Credential`オブジェクトが渡されると、認証の詳細を処理します。認証されたプリンシパルに基づく[認可](authorization.md)を行うために、フレームワーク開発者は登録時に`Credential.principal`を`FrameworkInfo.principal`にコピーする必要があります。

## CRAM-MD5 の例

1. 以下の内容でマスターの資格情報ファイルを作成します。

        {
          "credentials" : [
            {
              "principal": "principal1",
              "secret": "secret1"
            },
            {
              "principal": "principal2",
              "secret": "secret2"
            }
          ]
        }

2. 資格情報ファイルを使用してマスターを起動します（ファイルは`/home/user/credentials`であると仮定）

        ./bin/mesos-master.sh --ip=127.0.0.1 --work_dir=/var/lib/mesos --authenticate --authenticate_agents --credentials=/home/user/credentials

3. 1つのクレデンシャルを入れた別のファイル（`/home/user/agent_credential`）を作成します。

        {
          "principal": "principal1",
          "secret": "secret1"
        }

4. エージェントの起動:

        ./bin/mesos-agent.sh --master=127.0.0.1:5050 --credential=/home/user/agent_credential

5. 新しいエージェントは、マスターとの認証に成功しているはずです。

6. フレームワークの認証をテストするには、Mesosで提供されているテストフレームワークを以下のように使用します。

        MESOS_AUTHENTICATE=true DEFAULT_PRINCIPAL=principal2 DEFAULT_SECRET=secret2 ./src/test-framework --master=127.0.0.1:5050
