---
title: Apache Mesos - Fetcher
layout: documentation
---

# Mesos Fetcher

Mesos 0.23.0では、Mesos fetcher cacheを実験的にサポートしました。

この文脈では、ローカルファイルシステムからのコピーも含めて、「ダウンロード」という用語を緩く捉えています。

## Mesos fetcherとは？
Mesos fetcherは、タスクの実行に備えて、タスクの[サンドボックスディレクトリ](sandbox.md)にリソースをダウンロードするためのメカニズムです。TaskInfoメッセージの一部として、タスクの実行を指示するフレームワークが`CommandInfo::URI` protobuf値のリストを提供し、これがMesos fetcherの入力となります。

Mesosフェッチャーは、ローカルファイルシステムからファイルをコピーすることができ、HTTP、HTTPS、FTP、FTPSの各プロトコルもネイティブにサポートしています。要求されたURIが他のプロトコルに基づいている場合、フェッチャーはローカルのHadoopクライアントを利用しようとするため、HDFSやS3などのHadoopクライアントがサポートするあらゆるプロトコルをサポートします。Hadoopクライアントへのパスを使ってエージェントを設定する方法については、エージェントの[設定ドキュメント](configuration/agent.md)を参照してください。

デフォルトでは、リクエストされた各URIはサンドボックスディレクトリに直接ダウンロードされ、同じURIへのリクエストを繰り返すと、同じリソースの別のコピーをダウンロードすることになります。また、フェッチャーは、後続のダウンロードで再利用できるように、URIのダウンロードを専用のディレクトリにキャッシュするように指示することもできます。

Mesosのフェッチャー機構は、以下の2つの部分で構成されています。:
1. すべてのフェッチアクションを制御・調整するエージェント内部のフェッチャープロセス（libprocessの観点から）。すべてのエージェントインスタンスは、あらゆる種類のコンテナーライザーによって使用される、正確に1つの内部フェッチャーインスタンスを持っています。

2. 前者によって起動される外部プログラム`mesos-fetcher`。前者によって呼び出される外部プログラム`mesos-fetcher`は、キャッシュ内部の簿記のためのファイル削除とファイルサイズの問い合わせを除き、すべてのネットワークおよびディスク操作を行う。エージェントプロセスをI/O関連の危険から保護するために、外部のOSプロセスとして実行されます。フェッチアクションの詳細を記述したJSONオブジェクトを含む環境変数の形で指示を受けます。

## フェッチプロシージャー
フレームワークは、スケジューラドライバのメソッド `launchTasks()`を呼び出し、引数として `CommandInfo` protobuf 構造体を渡してタスクを起動します。このタイプの構造体は、タスク実行の前提条件として、エージェント・ノードのサンドボックス・ディレクトリに「フェッチ」する必要のあるコマンドとURIのリストを指定します。したがって、エージェントはタスク起動のリクエストを受け取ると、まずフェッチャーを呼び出して、指定されたリソースをサンドボックス・ディレクトリにプロビジョニングします。フェッチに失敗した場合、タスクは開始されず、報告されるタスク・ステータスは`TASK_FAILED`となります。

与えられたタスクに要求されたすべてのURIは、mesos-fetcherの1回の呼び出しで順次フェッチされます。ここでは、ダウンロードの同時実行を避けることで、帯域幅の問題のリスクが多少軽減されます。ただし、複数のタスク起動要求により、複数のフェッチ操作が同時にアクティブになる可能性があります。

### URIのprotobuf構造
mesos-fetcherが起動する前に、以下のprotobuf構造に基づいて、各URIに対して実行する特定のフェッチアクションが決定されます。(詳細は`include/mesos/mesos.proto`をご参照ください。)

    message CommandInfo {
      message URI {
        required string value = 1;
        optional bool executable = 2;
        optional bool extract = 3 [default = true];
        optional bool cache = 4;
        optional string output_file = 5;
      }
      ...
      optional string user = 5;
    }

フィールド "value"には、URIが格納されます。

executable "フィールドが "true "の場合、"extract "フィールドは無視され、何の影響もありません。

cache」フィールドが「true」の場合、URIに対してフェッチャーのキャッシュが使用されます。

output_file」フィールドが設定されている場合、フェッチャーはサンドボックス・ディレクトリに保存されているコピーにその名前を使用する。"output_file"には、ディレクトリ・コンポーネントが含まれる場合がありますが、その場合、記述されるパスは相対パスでなければなりません。

### ユーザー名の指定
フレームワークは、フェッチ・パラメータとなるユーザー名を渡すことができます。これにより、そのエクゼキュータやタスクは、特定のユーザの下で実行されます。ただし、CommandInfo構造体の「user」フィールドが指定されている場合は、影響を受けるタスクに優先して適用されます。

いずれの方法でもユーザ名が指定された場合、フェッチャーはまず、それが実際にエージェント上で有効なユーザ名であるかどうかを検証します。そうでない場合、フェッチはここで失敗します。そうでない場合は、フェッチ手順の最後、タスクの実行が始まる前に、サンドボックス・ディレクトリが（`chown`を使用して）所有者として指定されたユーザに割り当てられます。

再生されるユーザー名は、キャッシングに重要な影響を与えます。キャッシングはユーザーごとに管理されます。つまり、ユーザー名と「uri」の組み合わせによって、キャッシュ可能なフェッチ結果が一意に識別されます。ユーザー名が指定されていない場合、これも別のユーザーとしてキャッシュにカウントされます。このようにして、それぞれの有効なユーザのキャッシュファイルは、指定されていないものも含めて、他のすべてのユーザから分離されます。

これは、異なるユーザーが指定された場合、全く同じURIが複数回ダウンロードされ、キャッシュされることを意味します。

### 実行可能なフェッチ結果

デフォルトでは、フェッチされたファイルは実行可能ではありません。

フィールド "executable"が "true"に設定されている場合、フェッチ結果はすべてのユーザーに対して（"chmod"によって）実行可能なものに変更されます。これは、フェッチ手順の最後に、サンドボックス・ディレクトリ内でのみ行われます。どのキャッシュファイルにも影響はありません。

### アーカイブの抽出

"extract"フィールドがデフォルトの「true」の場合、パックされた、または圧縮されたアーカイブを示唆する、認識された拡張子を持つファイルは、サンドボックスディレクトリで解凍されます。認識される拡張子は以下のとおりです。:

- .tar, .tar.gz, .tar.bz2, .tar.xz
- .gz, .tgz, .tbz2, .txz, .zip

キャッシュがバイパスされている場合、アーカイブと解凍された結果の両方がサンドボックスに表示されます。キャッシュファイルが解凍された場合は、抽出結果のみがサンドボックス内に表示されます。

output_file」フィールドは、URIがクエリパラメータで終わっている場合に有用である。

### キャッシュを回避する

デフォルトでは、URIフィールド「cache」は存在しない。この場合、またはその値が「false」の場合、フェッチャーはサンドボックスのディレクトリに直接ダウンロードします。

また、キャッシュを含むフェッチ操作の準備中に何か問題が発生した場合、フォールバック戦略として同じことが動的に起こります。この場合には、警告メッセージが記録されます。可能なフォールバック条件は:

* URIを提供しているサーバーが応答しないか、エラーを報告している。
* URIのダウンロードサイズが確定できませんでした。
* ファイルの退避を試みても、キャッシュに十分な容量がありません。

### キャッシュを利用したフェッチ

URIの「cache」フィールドの値が「true」の場合、フェッチャーキャッシュが有効になります。あるURIに初めて遭遇した場合（同じユーザーの場合）、まずキャッシュにダウンロードされ、そこからサンドボックスのディレクトリにコピーされます。同じ URI に再び遭遇し、対応するキャッシュファイルがキャッシュに常駐しているか、またはキャッシュに入る途中であれば、ダウンロードは省略され、フェッチャーは直接キャッシュからのコピーに進みます。同じURIに対する競合するリクエストは、最初に発生したリクエストの完了を待つだけである。このように、すべてのURIは、キャッシュされている限り、（ユーザごとに）最大1回だけダウンロードされる。

すべてのキャッシュファイルは、不特定の時間常駐し、直接使用されている間を除いて、いつでもフェッチャーの判断で削除することができます。:

* このフェッチ・プロシージャによってまだダウンロードされています。
* 別のタスクの同時フェッチ・プロシージャによって、まだダウンロードされています。
* キャッシュからコピーまたは抽出されています。

いったんキャッシュファイルが削除されると、関連する URI はその後、最初に遭遇したときに上記のように処理されることになります。

残念ながら、フェッチャーキャッシュの現在の実験的なバージョンには、キャッシュエントリをリフレッシュするメカニズムはありません。将来の機能では、URI へのチェックサムクエリに基づいて更新を強制することができるかもしれません。

現時点での推奨事項

フレームワークは、リソースのコンテンツが変更されたときにはいつでも、新しい一意のURIの使用を開始すべきです。

### リソースサイズの決定

リソースをキャッシュにダウンロードする前に、フェッチャーはまず、予想されるリソースのサイズを決定します。URIの性質に応じて、これらの方法を使用します。

* ローカルファイルのサイズは、（シンボリックリンクをたどる）システムコールで探ります。
* HTTP/HTTPSのURIは、ヘッダの「content-length」フィールドを照会します。これは、`curl`によって実行されます。報告されたアセットサイズがゼロより大きくなければ、そのURIは無効とみなされます。
* FTP/FTPS は、執筆時点ではサポートされていません。
* その他のすべては、ローカルのHDFSクライアントによって照会されます。

これらのどれかがエラーを報告した場合、フェッチャーは上述のようにキャッシュをバイパスすることに戻ります。

警告: ダウンロードサイズを前もって問い合わせることができ、正確なサイズが確実に報告されるURIのみが、フェッチャーのキャッシュに関与する資格があります。実際のキャッシュファイルのサイズが何らかの方法でキャッシュディレクトリの物理的な容量を超えた場合、それ以降のエージェントの動作は全く規定されていません。疑わしい URI に対しては、キャッシュ機能を使用しないでください。

この問題を軽減するために、予想以上に大きいことが判明したキャッシュファイルは、要求されたコンテンツをダウンロードしてサンドボックスに配信した直後に削除されます。そのため、少なくとも総容量の超過が、その後のフェッチャーの実行で蓄積されることはありません。

サイズの異常が一定の範囲内であることが確実に分かっている場合は、実際の物理ボリュームよりも十分に小さいキャッシュディレクトリのサイズを指定すれば、フェッチが機能します。

キャッシュファイルのサイズが予想よりも小さかった場合、キャッシュは実際のサイズに応じて動的に調整します。

### キャッシュの排除

キャッシュファイルの予想されるサイズを決定した後、ダウンロードする前に、キャッシュは少なくともそのファイルに必要な容量が利用可能であり、書き込めることを確認しようとします。その結果、必要な容量が確保されていない場合は、単に予約済みと表示されます。そうでない場合、不足しているスペースは「キャッシュエヴィクション」によって解放されます。つまり、キャッシュは、指定されたスペース目標を満たすか超えるまで、自らの判断でファイルを削除します。

あまりにも多くのファイルが使用されていて立ち退きができない場合や、単にキャッシュが小さすぎる場合には、立ち退き処理は失敗します。いずれにしても、フェッチャーは上述のように、与えられたURIのキャッシュをバイパスすることに戻ります。

複数のエヴィジョンが同時に発生した場合、それぞれのエヴィジョンは個別のスペース目標を達成することになります。しかし、ある作業で残った解放されたスペースは、自動的に他の作業に与えられます。

## HTTPおよびSOCKSプロキシの設定
時には、プロキシを使用してファイルをダウンロードすることが望ましい場合があります。Mesos フェッチャーは、HTTP/HTTPS/FTP/FTPS サーバーからコンテンツをダウンロードするために libcurl を内部で使用しており、特定の環境変数が設定されている場合、libcurl は自動的にプロキシを使用することができます。

それぞれの環境変数名は `[protocol]_proxy` で、`protocol` は socks4, socks5, http, https のいずれかです。

例えば、`http_proxy`という環境変数の値は、httpのコンテンツを取得するためのプロキシとして使用され、`https_proxy`はhttpsのコンテンツを取得するためのプロキシとして使用されます。これらの変数名はすべて小文字であることに注意してください。

proxy変数の値は、`[protocol://][user:password@]machine[:port]`という形式で、`protocol`にはsocks4, socks5, http, httpsのいずれかを指定します。

プロキシを使用した FTP/FTPS リクエストでは、HTTP/HTTPS プロキシも使用されます。一般的には、これにより利用可能なFTPプロトコル操作が制限されますが、フェッチャーが使用するものはすべてサポートされています。

プロキシの設定は、`/etc/default/mesos-slave`に記述します。以下はその例です。:

```
export http_proxy=https://proxy.example.com:3128
export https_proxy=https://proxy.example.com:3128
```
フェッチャーが採用しているユーティリティプログラム`mesos-fetcher`はmesos-agentの子なので、フェッチャーはこれらの環境変数の設定を拾います。

詳細については、[libcurlのマニュアル](http://curl.haxx.se/libcurl/c/libcurl-tutorial.html)をご参照ください。

## エージェント フラグ
これらのフラグは、デフォルト以外の値を明示的に設定するか、運用時にはフェッチャーキャッシュを使用しないことを強くお勧めします。

* "fetcher_cache_size": デフォルト値：テスト用には十分です。
* "fetcher_cache_dir": デフォルト値: "work_dir" フラグで指定されたディレクトリ内のどこかで、テスト用には問題ありません。

推奨環境:

* フェッチャーキャッシュとして別のボリュームを使用する。フェッチャーキャッシュのディレクトリとして、基礎となるボリュームの領域を他の貢献者と競合するディレクトリを指定しないでください。
* エージェントのキャッシュディレクトリサイズフラグを、実際のキャッシュボリュームの物理サイズよりも小さく設定します。特に、すべてのフレームワークが準拠しているかどうかはっきりしない場合は、安全マージンを使用する。

究極の解決策:

各エージェントの "fetcher_cache_size"フラグを0バイトに設定することで、フェッチャーキャッシュを完全に無効にすることができます。

## 将来の機能
以下の機能は、比較的容易に追加実装することができます。

* リソースのチェックサムに基づいて、キャッシュの更新を行います。たとえば、HTTP ヘッダーの md5 フィールドを照会して、ある URL のリソースが変更されたかどうかを判断します。
* HTTP の cache-control ディレクティブを尊重します。
* ftp/ftpsのキャッシュを有効にする。
* シンボリックリンクまたはバインドマウントを使用して、キャッシュされたリソースを読み取り専用でサンドボックスに投影します。
* 抽出したアーカイブをサンドボックスにコピーするかどうかを選択できます。
* 抽出したアーカイブをサンドボックスにコピーするかどうかを選択できます。
* キャッシュファイルのユーザごとの分離を任意とする。
* キャッシュを迂回してダウンロードする際にコンテンツを抽出する。
* 後続のタスクのためにリソースをプリフェッチします。これは、現在のタスクの実行と同時に、それ自身のリソースを取得した直後に行うことができます。

## 実装内容
[Mesos Fetcher Cache Internals](fetcher-cache-internals.md)では、フェッチャーキャッシュの実装方法について説明しています。
